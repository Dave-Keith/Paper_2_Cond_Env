---
title: "BNAM bottom temperature vs. condition"
output:
  pdf_document: default
  word_document: default
editor_options: 
  chunk_output_type: console
---

# Prep, just adding to existing code. 

```{r, message=F, warning=F}
# Data loading and analysis
set.seed(594)
#setwd("Y:/Projects/Condition_Environment/Data/")
setwd("Y:/Projects/Condition_Environment/")
# directory you have the survey results stored in...
direct <- "Y:/Offshore/Assessment/Data/Survey_data/2018/Survey_summary_output/"
#direct <- "E:/R/Data/Survey_data/2018/Survey_summary_output/"

# Looking a relationship between Condition and SST and phytoplankton
library(MASS)
library(readxl)
library(bbmle)
library(ggplot2)
library(gridExtra)
library(reshape2)
library(mgcv)
library(lubridate)
library(pander)
library(scales)
library(R.matlab)
library(cowplot)
require(formatR)

knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)

source("Scripts/correlation_table_function_revised.r")
# Here we load in the raw data and get everything ready for further analyses.
#----------------------------------------------------------------------------------
# RAW Data Section
# Bring in the raw data.
chl.raw.dat <- as.data.frame(readMat("Data/chl_gb.mat")$chl.gb)
mic.raw.dat <- as.data.frame(readMat("Data/mic_gb.mat")$mic.gb)
mld.raw.dat <- as.data.frame(readMat("Data/mld_gb.mat")$mld.gb)
sst.raw.dat <- as.data.frame(readMat("Data/sst_gb_adj.mat")$gb)
bt.raw.dat <- dplyr::select(read.csv("Data/bt_gb.csv"), -X, -monthnum)

names(chl.raw.dat) <- c("Year","Month","covar","mystery.covar")
names(mic.raw.dat) <- c("Year","Month","covar","mystery.covar")
names(mld.raw.dat) <- c("Year","Month","covar","mystery.covar")
names(sst.raw.dat) <- c("Year","Month","covar")
names(bt.raw.dat) <- c("Year", "Month", "covar")

bt.raw.dat$Month <- match(bt.raw.dat$Month, month.abb)

# dat.aug <- read_xlsx("Data/Scallop_condition_with_same_SST_covariates.xlsx",sheet = "Aug",col_types = "numeric")
# dat.may <- read_xlsx("Data/Scallop_condition_with_same_SST_covariates.xlsx",sheet = "May",col_types = "numeric")

# We want a month-Year combo field for these
sst.raw.dat$date <- dmy(paste(01,sst.raw.dat$Month,sst.raw.dat$Year, sep="/"))
sst.raw.dat$Year <- year(sst.raw.dat$date)
sst.raw.dat$Month <- month(sst.raw.dat$date)
bt.raw.dat$date <- dmy(paste(01,bt.raw.dat$Month,bt.raw.dat$Year, sep="/"))
bt.raw.dat$Year <- year(bt.raw.dat$date)
bt.raw.dat$Month <- month(bt.raw.dat$date)
chl.raw.dat$date <- dmy(paste(01,chl.raw.dat$Month,chl.raw.dat$Year, sep="/"))
chl.raw.dat$Year <- year(chl.raw.dat$date)
chl.raw.dat$Month <- month(chl.raw.dat$date)
mic.raw.dat$date <- dmy(paste(01,mic.raw.dat$Month,mic.raw.dat$Year, sep="/"))
mic.raw.dat$Year <- year(mic.raw.dat$date)
mic.raw.dat$Month <- month(mic.raw.dat$date)
mld.raw.dat$date <- dmy(paste(01,mld.raw.dat$Month,mld.raw.dat$Year, sep="/"))
mld.raw.dat$Year <- year(mld.raw.dat$date)
mld.raw.dat$Month <- month(mld.raw.dat$date)
# now bring in the condition data of the whole time series.
# This is used to get the acf for condition from the whole time series of condition we have
base.cond.ts <- read.csv("Data/Full_may_aug_condition_ts.csv")

# base.cond.ts from 1998 on matches dat.aug and dat.may
# ggplot() + geom_point(data=base.cond.ts, aes(year, aug), colour="blue") +
#   geom_point(data=base.cond.ts, aes(year, may), colour="red") + 
#   geom_point(data=dat.aug, aes(Year, Condition), colour="lightblue") + 
#   geom_point(data=dat.may, aes(Year, Condition), colour="pink")

# Building these by hand because I don't know where the SST data in the XLSX files came from
dat.aug <- data.frame(Year=base.cond.ts$year[base.cond.ts$year>1997], 
                      Condition=base.cond.ts$aug[base.cond.ts$year>1997])
dat.may <- data.frame(Year=base.cond.ts$year[base.cond.ts$year>1997], 
                      Condition=base.cond.ts$may[base.cond.ts$year>1997])


# Now we want these as anomolies from average, so starting with SST...
sst.raw.dat$anom <- sst.raw.dat$covar - mean(sst.raw.dat$covar,na.rm=T)
bt.raw.dat$anom <- bt.raw.dat$covar - mean(bt.raw.dat$covar,na.rm=T)
chl.raw.dat$anom <- chl.raw.dat$covar - mean(chl.raw.dat$covar,na.rm=T)
chl.raw.dat$myst.anom <- chl.raw.dat$mystery.covar - mean(chl.raw.dat$mystery.covar,na.rm=T)
mic.raw.dat$anom <- mic.raw.dat$covar - mean(mic.raw.dat$covar,na.rm=T)
mic.raw.dat$myst.anom <- mic.raw.dat$mystery.covar - mean(mic.raw.dat$mystery.covar,na.rm=T)
mld.raw.dat$anom <- mld.raw.dat$covar - mean(mld.raw.dat$covar,na.rm=T)
mld.raw.dat$myst.anom <- mld.raw.dat$mystery.covar - mean(mld.raw.dat$mystery.covar,na.rm=T)

# Now we want to remove the "seasonal" signal, one way to do this would be to remove the 
# mean temperature anomoly found for each month, so for January, subtract off the mean Jan temp anomoly...
for(i in 1:12) 
{  
  # Sea surface temp
  sst.raw.dat$anom.seasonal[sst.raw.dat$Month == i] <- 
    sst.raw.dat$anom[sst.raw.dat$Month == i] - 
    mean(sst.raw.dat$anom[sst.raw.dat$Month == i],na.rm=T)
  # Bottom temp
  bt.raw.dat$anom.seasonal[bt.raw.dat$Month == i] <- 
    bt.raw.dat$anom[bt.raw.dat$Month == i] - 
    mean(bt.raw.dat$anom[bt.raw.dat$Month == i],na.rm=T)
  
  # Chlorophyll
  chl.raw.dat$anom.seasonal[chl.raw.dat$Month == i] <- 
    chl.raw.dat$anom[chl.raw.dat$Month == i] -
    mean(chl.raw.dat$anom[chl.raw.dat$Month == i],na.rm=T)
  
  chl.raw.dat$anom.sea.myst[chl.raw.dat$Month == i] <- 
    chl.raw.dat$myst.anom[chl.raw.dat$Month == i] -
    mean(chl.raw.dat$myst.anom[chl.raw.dat$Month == i],na.rm=T)
  # Micro phyto
  mic.raw.dat$anom.seasonal[mic.raw.dat$Month == i] <- 
    mic.raw.dat$anom[mic.raw.dat$Month == i] -
    mean(mic.raw.dat$anom[mic.raw.dat$Month == i],na.rm=T)
  
  mic.raw.dat$anom.sea.myst[mic.raw.dat$Month == i] <- 
    mic.raw.dat$myst.anom[mic.raw.dat$Month == i] -
    mean(mic.raw.dat$myst.anom[mic.raw.dat$Month == i],na.rm=T)
  # MLD
  mld.raw.dat$anom.seasonal[mld.raw.dat$Month == i] <- 
    mld.raw.dat$anom[mld.raw.dat$Month == i] -
    mean(mld.raw.dat$anom[mld.raw.dat$Month == i],na.rm=T)

  mld.raw.dat$anom.sea.myst[mld.raw.dat$Month == i] <- 
    mld.raw.dat$myst.anom[mld.raw.dat$Month == i] -
    mean(mld.raw.dat$myst.anom[mld.raw.dat$Month == i],na.rm=T)
}

#Now we can get the monthly SST, CHla, and MLD estimates, this is used for the first figure in the paper.
chl.mon <- aggregate(covar~ Month,data = chl.raw.dat,FUN=mean)
chl.mon$sd <- aggregate(covar~ Month,data = chl.raw.dat,FUN=sd)[,2]
chl.mon$variable <- "chl"
sst.mon <- aggregate(covar~ Month,data = sst.raw.dat,FUN=mean)
sst.mon$sd <- aggregate(covar~ Month,data = sst.raw.dat,FUN=sd)[,2]
sst.mon$variable <- "sst"

bt.mon <- aggregate(covar~ Month,data = bt.raw.dat,FUN=mean)
bt.mon$sd <- aggregate(covar~ Month,data = bt.raw.dat,FUN=sd)[,2]
bt.mon$variable <- "bt"

mld.mon <- aggregate(covar~ Month,data = mld.raw.dat,FUN=mean)
mld.mon$sd <- aggregate(covar~ Month,data = mld.raw.dat,FUN=sd)[,2]
mld.mon$variable <- "mld"

month.dat <- rbind(chl.mon,
                   sst.mon,
                   bt.mon,
                   mld.mon
                   )

# Here we get the data we want for the correlation figures, making one
# for August SST, Chl, MLD, and MIC not sure which ones we'll use yet...

dat.list <- list(#chl = chl.raw.dat,mic = mic.raw.dat,mld = mld.raw.dat,
  sst = sst.raw.dat,
  bt = bt.raw.dat)
cond.list <- list(aug = dat.aug,may = dat.may)
res <- NULL
for(i in 1:length(dat.list))
{
  for(j in 1:length(cond.list))
  {
    res[[paste(names(dat.list)[i],names(cond.list)[j],sep="_")]] <- 
      cor_dat(dat = dat.list[[i]], response = cond.list[[j]])
  }  # end for(j in 1:length(cond.list))
} # end for(i in 1:length(dat.list))

```

# Identifying correlation timing

```{r correlation, echo=F, include=T,warning=F,echo=F,message=F,fig.width=12,fig.height=5}
dat.list <- list(sst = sst.raw.dat,#chl = chl.raw.dat,mld = mld.raw.dat, 
                 bt = bt.raw.dat)
cond.list <- list(aug = dat.aug, may=dat.may)
res <- NULL
n.months <- 19
for(i in 1:length(dat.list))
{
  for(j in 1:length(cond.list))
  {
    res[[paste(names(dat.list)[i],names(cond.list)[j],sep="_")]] <- cor_dat(dat = dat.list[[i]], response = cond.list[[j]],n.months = n.months,last.month =7)
  }  # end for(j in 1:length(cond.list))
} # end for(i in 1:length(dat.list))

mods <- names(res)
num.mods <- length(mods)
str.names <- c(paste(c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"),"last",sep=" "),
               paste(c("Jan","Feb","Mar","Apr","May","Jun","Jul"),"cur",sep=" "))
aug.mods <- grep(pattern="aug", mods)
may.mods <- grep(pattern="may", mods)
p1<- NULL
#pdf(file = "Figures/R2_and_correlation_for_covariates.pdf",onefile=T,width = 32, height = 8)
for(i in 1:num.mods)
{
tmp <- res[[i]]
#print(paste("R2 range=" , range(tmp$resp$r2,na.rm=T)))
#print(paste("Pearson range=" , range(tmp$resp$pearson,na.rm=T)))
#print(paste("Kendall range=" , range(tmp$resp$kendall,na.rm=T)))
print(mods[i])
print("Last year:")
LY <- res[[i]]$resp[res[[i]]$resp$start.num<13 & res[[i]]$resp$end.num < 13 & !is.na(res[[i]]$resp$p.r2.lev),]
print(LY[which(LY$r2 == max(LY$r2)),])
print("Current year:")
CY <- res[[i]]$resp[res[[i]]$resp$start.num>12 & res[[i]]$resp$end.num > 12 & !is.na(res[[i]]$resp$p.r2.lev),]
print(CY[which(CY$r2 == max(CY$r2)),])


p <- ggplot(tmp$resp, aes(end.num,start.num)) + scale_x_continuous(name= "End month", breaks=1:n.months, labels = str.names) +
     scale_y_continuous(name= "Start month", breaks=1:n.months,labels = str.names) +
     theme_classic() + theme(text = element_text(size=20),axis.text.x = element_text(angle = -30, hjust=0)) 

p1[[i]] <- p + geom_raster(aes(fill = r2)) +  scale_fill_gradientn(limits = c(0,0.7),colours=c("blue","white","red")) +
          geom_text(aes(label= p.r2.lev, angle=0,hjust=0.5,vjust=1),colour="black")+ annotate("text",x=1,y=n.months,label=mods[i])

print(p1[[i]])
# p2 <- p+ geom_raster(aes(fill = kendall)) + scale_fill_gradientn(limits = c(-0.4,0.8),colours=c("blue","white","red"))+
#          geom_text(aes(label= p.kend.lev, angle=0,hjust=0.5,vjust=1),colour="black") +  ggtitle(mods[i])

} # end for(i in 1:num.mods)
# 
# plot_grid(p1[[aug.mods[1]]], p1[[aug.mods[2]]], 
#           #p1[[aug.mods[3]]], p1[[aug.mods[4]]], 
#           align="v", nrow=length(aug.mods), rel_widths=1.5)
# plot_grid(p1[[may.mods[1]]], p1[[may.mods[2]]], 
#           #p1[[may.mods[3]]], p1[[may.mods[4]]], 
#           align="v", nrow=length(may.mods), rel_widths=1.5)

```


# August correlation-informed aggregations
```{r, message=F, warning=F}
#----------------------------------------------------------------------------------
# AUGUST FIRST
# Sub-Section where we create the aggregated time series.
#Putting the indices together...
# SO based on the above analyses, it is pretty clear that mld and chl 'a' really 
# aren't doing anything on their own.  What
# stands out is SST in the previous spring and the current spring.  
# The previous spring SST is best represented by Jan-April, while this years is Jan-Mar.
# So this decision is still somewhat arbitrary and I think we should all chat abou it at some point...
# the most stats logical move is to use SST from Jan-April last year, and Jan-March this year
# But from a consistency point of view, Jan-March of both years is very useful
# And from an applied point of view, given the timing of the advice, seemingly
# using Jan/Feb of the current year, but Jan-Mar is the better choice
#  So after much consternation we go for...

# For SST use Jan-April last year and Jan-March this year as the model of choice (makes sense and gives excellent model fit..)
SST.last <- aggregate(covar ~ Year, 
                      data=sst.raw.dat[sst.raw.dat$Month %in% 1:4,], FUN = sum)
names(SST.last) <- c("Year","SST.last")

BT.last <- aggregate(covar ~ Year, 
                     data=bt.raw.dat[bt.raw.dat$Month %in% 4 & 
                                       bt.raw.dat$Year %in% sst.raw.dat$Year,], FUN = sum)
names(BT.last) <- c("Year","BT.last") 
BT.last$BT.last <-  c(NA,BT.last$BT.last[-nrow(BT.last)])

dat <- aggregate(covar ~ Year, 
                 data=sst.raw.dat[sst.raw.dat$Month %in% 1:3,], FUN = sum)
names(dat) <- c("Year","SST.cur")

dat$SST.last <-  c(NA,SST.last$SST.last[-nrow(SST.last)])

dat <- dplyr::left_join(dat, BT.last, by="Year")

aug.dat <- dat

aug.dat$Condition <- dat.aug$Condition
# Also make an SST sum covar
aug.dat$SST.sum <- aug.dat$SST.cur + aug.dat$SST.last

```


# May correlation-informed aggregations
```{r, message=F, warning=F}
SST.last <- aggregate(covar ~ Year, 
                      data=sst.raw.dat[sst.raw.dat$Month %in% 2:3,], FUN = sum)
names(SST.last) <- c("Year","SST.last")

dat <- aggregate(covar ~ Year, 
                 data=sst.raw.dat[sst.raw.dat$Month %in% 1:2,], FUN = sum)
names(dat) <- c("Year","SST.cur")

dat$SST.last <-  c(NA,SST.last$SST.last[-nrow(SST.last)])

dat.bt <- aggregate(covar ~ Year, 
                    data=bt.raw.dat[bt.raw.dat$Month %in% 4 & 
                                      bt.raw.dat$Year %in% sst.raw.dat$Year,], FUN = sum)
names(dat.bt) <- c("Year","BT.cur")

dat <- dplyr::left_join(dat, dat.bt, by="Year")

may.dat <- dat
may.dat$Condition <- dat.may$Condition
# Also make an SST sum covar
may.dat$SST.sum <- may.dat$SST.cur + may.dat$SST.last

```

# Model selection
```{r, message=F, warning=F}
#----------------------------------------------------------------------------------
# Now we run the analyses necessary for the paper.

# Now we can omit the years we don't have data right off the top, a bit too harsh but good for model comparisons...
aug.dat.comp <- na.omit(aug.dat)
may.dat.comp <- na.omit(may.dat)

# correlation between sst and bt
cor.test(aug.dat.comp$SST.last, aug.dat.comp$BT.last)

aug.sst.last <- lm(data=aug.dat.comp, Condition ~ SST.last)
aug.sst.cur <- lm(data=aug.dat.comp, Condition ~ SST.cur)
aug.bt.last <- lm(data=aug.dat.comp, Condition ~ BT.last)
summary(aug.sst.last)
summary(aug.sst.cur)
summary(aug.bt.last)

aug.sst.sum <- lm(data=aug.dat.comp, Condition ~ SST.sum)
aug.sst.sum2 <- lm(data=aug.dat.comp, Condition ~ SST.last + SST.cur)
summary(aug.sst.sum)
summary(aug.sst.sum2)

aug.sst.sum3 <- lm(data=aug.dat.comp, Condition ~ SST.last + BT.last)
aug.sst.sum4 <- lm(data=aug.dat.comp, Condition ~ SST.cur + BT.last)
summary(aug.sst.sum3)
summary(aug.sst.sum4)

aug.sst.int <- lm(data=aug.dat.comp, Condition ~ SST.last*SST.cur)
aug.sst.int2 <- lm(data=aug.dat.comp, Condition ~ SST.last*SST.cur + BT.last)
summary(aug.sst.int)
summary(aug.sst.int2)


AICctab(aug.sst.last, aug.sst.cur, aug.bt.last, 
        aug.sst.sum, aug.sst.sum2,
        aug.sst.sum3, aug.sst.sum4,
        aug.sst.int, aug.sst.int2)


# SST sum wins for August, but it's better to use the explicit model so:
summary(aug.sst.sum2)

# What about May?
may.sst.last <- lm(data=may.dat.comp, Condition ~ SST.last)
may.sst.cur <- lm(data=may.dat.comp, Condition ~ SST.cur)
may.bt.cur <- lm(data=may.dat.comp, Condition ~ BT.cur)
summary(may.sst.last)
summary(may.sst.cur)
summary(may.bt.cur)

may.sst.sum <- lm(data=may.dat.comp, Condition ~ SST.sum)
may.sst.sum2 <- lm(data=may.dat.comp, Condition ~ SST.last + SST.cur)
summary(may.sst.sum)
summary(may.sst.sum2)

may.sst.sum3 <- lm(data=may.dat.comp, Condition ~ SST.last + BT.cur)
may.sst.sum4 <- lm(data=may.dat.comp, Condition ~ SST.cur + BT.cur)
summary(may.sst.sum3)
summary(may.sst.sum4)

may.sst.int <- lm(data=may.dat.comp, Condition ~ SST.last*SST.cur)
may.sst.int2 <- lm(data=may.dat.comp, Condition ~ SST.last*SST.cur + BT.cur)
summary(may.sst.int)
summary(may.sst.int2)


AICctab(may.sst.last, may.sst.cur, may.bt.cur, 
        may.sst.sum, may.sst.sum2,
        may.sst.sum3, may.sst.sum4,
        may.sst.int, may.sst.int2)

#sst.sum3 wins
summary(may.sst.sum3)

```


# Autocorrelation within condition

## Instructions...
The next bit is doing the autocorrelation analysis, is there autocorrelation in condition time series (that is already in my code I'm 99% sure), but then also using the last 2,5,10 year (or X years) median condition to see if any of those are decent predictors of next years condition.  I suspect using last years condition is the best and that's the 'non-environmental' predictive model we'd use to compare with the environmental model. But this will be a useful exercise to see how well using a LTM of some sort to predict condition does so we can tell industry we did all this analysis and none of it helps.
You can ignore the May stuff I think from here out, let's just dial in on August.
After that we pick 2-3 models and do the biomass predictions with them.  Undecided if we drop bottom temperature at this stage given your results, or we toss in a bottom temperature model that we know isn't great just to have a couple of environmental models in there...

### Original (one-year lag autocorrelation?)
```{r}
# Now we can look at the acf of condition on GB for 1999 - 2018, issue here is the data may not be stationary so need to detrend the longer ts
# gb.may.cf <- base.cond.ts$may[base.cond.ts$year %in% 1999:2015]
gba.aug.cf <- base.cond.ts$aug[base.cond.ts$year %in% 1984:2018]
# gb.detrend <- resid(lm(gb.may.cf~ seq(1,length(gb.may.cf)),na.action = na.exclude))
gba.detrend <- resid(lm(gba.aug.cf~ seq(1,length(gba.aug.cf)),na.action = na.exclude))
acfs <- acf(gba.detrend, plot = FALSE,na.action = na.pass)
plot(acfs)
acfs <- with(acfs, data.frame(lag, acf))
# So a lag linear model...
lag.aug.dat <- aug.dat[aug.dat$Year %in% 1984:2018,]
lag.aug.dat$cond.covar <- c(NA,lag.aug.dat$Condition[1:(nrow(lag.aug.dat)-1)])
lag.aug.mod <- lm(Condition ~ cond.covar,lag.aug.dat)
summary(lag.aug.mod)
# Finally make the NULL model
null.aug.mod <- lm(Condition~1,aug.dat.comp)
```

### Long term median autocorrelation? 
```{r}
# build a function to use any number of years
lastNyears_med <- function(N){
  lag <- NULL
  for(i in (N+1):length(lag.aug.dat$Condition)){
    lagged <- median(lag.aug.dat$Condition[(i-N):(i-1)])
    lag <- c(lag, lagged)
  }
  lag <- c(rep(NA, N), lag)
  lag.median <- cbind(lag.aug.dat, lag)
  
  mod <- lm(data=lag.median, Condition ~ lag)
  
  return(list(lag.median, mod))
  
}

# try 2, 5, 10 years
medyrs2 <- lastNyears_med(2)
medyrs5 <- lastNyears_med(5)
medyrs10 <- lastNyears_med(10)

summary(medyrs2[[2]])
summary(medyrs5[[2]])
summary(medyrs10[[2]])

mod2 <- lm(data=medyrs2[[1]][11:nrow(medyrs2[[1]]),], Condition ~ lag)
mod5 <- lm(data=medyrs5[[1]][11:nrow(medyrs5[[1]]),], Condition ~ lag)
mod10 <- lm(data=medyrs10[[1]][11:nrow(medyrs10[[1]]),], Condition ~ lag)

AICctab(mod2, mod5, mod10)

```
