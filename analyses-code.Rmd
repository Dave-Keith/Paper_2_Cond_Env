<!-- Set the theme for the figures -->
```{r theme, echo=F, include=F, paged.print=FALSE,cache =F}
theme_set(theme_few(base_size = 12))
```



<!-- Bring in the data + figures   -->

```{r sst-model, echo=F, include=F, paged.print=FALSE,cache =T}

cond.aug <- data.frame(year = survey.obj$GBa[[1]]$year, CF=survey.obj$GBa[[1]]$CF)
cond.aug  <- cond.aug %>% dplyr::filter(year >= 1986)
cond.all <- left_join(cond.aug,cond.dat,by = 'year')
names(cond.all) <- c("year","Aug","May")

#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!
#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!
# So I'm running a model to convert between August condition and May condition in the 2 years
# we are missing those data (1989,2015).  I ran a linear model for pre-2000 to 
# estimate the relationship in the first half of the time series and used that for 1989
# While I ran a model from 2000 onwards to imput the number for 2015.
# Using an old and new model made almost no difference with the 1989 estiamte compared to just using one condition model
# While it changes the condition estimate by around 0.4 in 2015.  Since it change 2015 that much
# I decided to keep the new models here.
may.aug.mod.old <- lm(May~Aug,cond.all %>% dplyr::filter(year < 2000))
may.aug.mod.new <- lm(May~Aug,cond.all %>% dplyr::filter(year >= 2000))

# Notice that I'm filling in the 1989 and 2015 condition in May based on the Aug condition in those years
# and the linearl relationship between condition in Aug and May.
Aug.old = cond.aug %>% dplyr::filter(year %in% c(1989)) %>% dplyr::select(CF)
Aug.new = cond.aug %>% dplyr::filter(year %in% c(2015)) %>% dplyr::select(CF)
pred.dat.old <- data.frame(year = c(1989), 
                       Aug = Aug.old$CF,
                       May = c(NA))

pred.dat.new <- data.frame(year = c(2015), 
                       Aug = Aug.new$CF,
                       May = c(NA))

pred.dat.old$May <- predict(may.aug.mod.old,pred.dat.old) # 13.3, 15.6
pred.dat.new$May <- predict(may.aug.mod.new,pred.dat.new) # 13.3, 15.6
pred.dat <- rbind(pred.dat.old,pred.dat.new)

cond.all$May[cond.all$year %in% c(1989,2015)] <- pred.dat$May
cond.may <- cond.all[,names(cond.all) != "Aug"]
names(cond.may) <- c("year","CF")
acf(cond.all$Aug,plot=F)
#cond.all.long <- reshape2::melt(cond.all,id = 'year')

# So data shows this is very much just an offset, slope is 1:1, but AMay tends to be lower than August
#ggplot(cond.all,aes(y = May, x = Aug)) + geom_label(aes(label = year)) + geom_abline() + geom_smooth(method = 'lm')
#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!
#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!#### IMPORANT NOTE DK!!!!

# All of this modelling used May condition instead of August condition which is what we use in the model
# Given August condition is even higher than May condition I expect it would be even more biased...

last.sst <- dat %>% dplyr::filter(Month %in% 1:3) %>% group_by(Year) %>% dplyr::summarise(sst.last = mean(SST,na.rm=T))
# SO this will align the last sst with next year.
last.sst$Year <- last.sst$Year + 1
# And the current year uses Jan and Feb.
this.sst <- dat %>% dplyr::filter(Month %in% 1:2) %>% group_by(Year) %>% dplyr::summarise(sst.this = mean(SST,na.rm=T))

sst.dat <- left_join(this.sst,last.sst,by= "Year")
names(sst.dat) <- tolower(names(sst.dat))
# So I'm using May condition for all comparisons, this is good I think.
all.dat <- left_join(sst.dat,cond.may,by='year')
names(cond.aug) <- c("year","CF.aug")
all.dat <- left_join(all.dat,cond.aug,by='year')

# Toss 1985 and 2020 since no CF data for either
all.dat <- all.dat %>% dplyr::filter(!year %in% c(1985,2020))


mod.all <- lm(CF~ sst.this + sst.last,data = all.dat)
summary(mod.all)

#Based on the paper I'm kinda leaning towards just using the last model to see how well it does...
mod.last <- lm(CF~ sst.last,data = all.dat)
summary(mod.last)

# The ACf model, going to fit as an LM so I can get the R^2 directly and to keep things consistent...
mod.acf <- lm(CF[2:nrow(all.dat)] ~ CF[1:(nrow(all.dat)-1)],all.dat)
summary(mod.acf)

# To compare models using AIC I need to drop the first year of data so we have the same length response variable...
aic.dat <- all.dat[-1,]
mod.all.aic <-  lm(CF~ sst.this + sst.last,data = aic.dat)
mod.last.aic <-  lm(CF~ sst.last,data = aic.dat)
# Now I can compare the 3 models
aic.res <- AICctab(mod.acf,mod.all.aic,mod.last.aic,base=T,logLik =T)
names(aic.res) <- c("LL", "AICc", "Delta LL", "Delta AICc", "df")
attr(aic.res,"row.names") <- c("Full", "Previous", "Current")

write.csv(print(aic.res),paste0(direct.proj,"Results/AIC_tab.csv"))

# Now show the fit for the 3 models, they are all simple linear models so easy peasy...

p1 <- ggplot(all.dat,aes(x=I(sst.this+sst.last),y = CF)) + geom_text(aes(label=substr(year,3,4))) + 
                          stat_smooth(method = 'lm') + 
                          xlab("SST (Previous Year + Current Year)") + ylab("Current Year SC (grams)")

p2 <- ggplot(all.dat,aes(x=sst.last,y = CF)) + geom_text(aes(label=substr(year,3,4))) + 
                          stat_smooth(method = 'lm') + 
                          xlab("SST Previous Year") + ylab("")
all.dat$CF_off <- c(all.dat$CF[2:nrow(all.dat)],NA)

p3 <- ggplot(all.dat,aes(x=CF_off,y = CF)) + geom_text(aes(label=substr(year,3,4))) + 
                          stat_smooth(method = 'lm') + 
                          xlab("Previous Year SC (grams)") + ylab("")

p.sc <- plot_grid(p1,p2,p3,nrow=1)
save_plot(plot= p.sc,filename = paste0(direct.proj,"Results/Figures/SC_models.png"),base_height = 5,base_width = 10)

# Get our predicted CF and compare to the Predicted condition we actually used
all.dat$CF.all <- predict(mod.all,all.dat)
all.dat$CF.last <- predict(mod.last,all.dat)
#all.dat$CF.used <- c(all.dat$CF[2:(nrow(all.dat))],NA)
# Now take the difference between the different predictive models and the actual condition observed
all.dat$diff.CF.all <- all.dat$CF.all - all.dat$CF
all.dat$diff.CF.last <- all.dat$CF.last - all.dat$CF
#all.dat$diff.CF.used <- all.dat$CF.used - all.dat$CF
#all.dat$improve.CF.last <- ifelse(abs(all.dat$diff.CF.last) < abs(all.dat$diff.CF.used),1,0)
# So the prediction is closer than our current method in 20 of 29 years with the pred.all.improve model.
# So there is solid evidence that this method is better than what we are doing now.  Now the question is, does it matter
#all.dat$improve.CF.all <- ifelse(abs(all.dat$diff.CF.all) < abs(all.dat$diff.CF.used),1,0)
# Now what is the predictive error from the different methods overall, perhaps it is so small that we probably won't care.
all.dat$perc.diff.CF.all <- 100*(all.dat$diff.CF.all)/all.dat$CF
all.dat$perc.diff.CF.last <- 100*(all.dat$diff.CF.last)/all.dat$CF
#all.dat$perc.diff.CF.used <- 100*(all.dat$diff.CF.used )/all.dat$CF

# Now we need the SH data to get the the growth rates.
all.dat <- left_join(all.dat,sh.dat,by='year')


# Now start the growth calculations.... Here's the 'known' weight in year X based on either the May or August survey
all.dat$waa.tm1 <- all.dat$CF*(all.dat$l.fr/100)^3
#all.dat$waa.tm1.aug <- all.dat$CF.aug*(all.dat$l.fr/100)^3

# Using this years average shell height we can find the exptected shell height for the scallops in the next year
# ht = (Linf * (1-exp(-K)) + exp(-K) * height(last year))
# laa.t is the projected size of the current years scallops into next year.
all.dat$laa.t <- vonB$Linf*(1-exp(-vonB$K)) + exp(-vonB$K) * all.dat$l.fr
# The c() term in the below offsets the condition so that current year's condition slots into the previous year and repeats 
# the condition for the final year), this effectively lines up "next year's condition" with "predictied shell height next year (laa.t)
# This gets us the predicted weight of the current crop of scallops next year based on next years CF * laa.t^3
# Of course we don't have next years condition thus th last condition is simply repeated
# waa.t is using the condition from next year and the growth from next year to get next years weight
all.dat$waa.t.used <- all.dat$CF*(all.dat$laa.t/100)^3
#all.dat$waa.t.aug <-  all.dat$CF.aug*(all.dat$laa.t/100)^3 # Becuase we are assuming condition doesn't change, the Aug and May scenarios 
# Actually turn out to be identical, because all you have is the growth term in there and the conditions cancel out!


# But for the modelled data I want to use the following year data because it's the spring 1987 info 
# that we use to predict 1987 condition right.  Hurting my head!! So 1987 condition by 1986 survey size data.
all.dat$waa.t.all <- c(all.dat$CF.all[2:nrow(all.dat)],NA)*(all.dat$laa.t/100)^3
all.dat$waa.t.last <- c(all.dat$CF.last[2:nrow(all.dat)],NA)*(all.dat$laa.t/100)^3


# Here we use the current condition factor to calculate the weight next year (since we use laa.t)
# That's really the only difference between waa.t and waa.t2, waa.t uses next years condition to project growth
# what waa.t2 uses the current condition to project growth.  So that's really what we are comparing here with these
# two growth metrics isn't it, this is really just comparing impact of using current vs. future condition factor on our growth estimates.

all.dat$waa.t2 <- c(all.dat$CF[2:nrow(all.dat)],NA)*(all.dat$laa.t/100)^3 # This is the 'realized' weight next year using May data, really just 
#using the growth projection * CF for next year.
#all.dat$waa.t2.aug <- c(all.dat$CF.aug[2:nrow(all.dat)],NA)*(all.dat$laa.t/100)^3
# Now the growth, expected and realized.
#Note everything in these growth in "1986" is actually used for projections in 1987.
all.dat$g.used <- all.dat$waa.t.used/all.dat$waa.tm1 # This is the growth estimate that would have been used in the model
all.dat$g.all <- all.dat$waa.t.all/all.dat$waa.tm1 # This is the growth estimate we'd use if we used the full SST predictive model
all.dat$g.last <- all.dat$waa.t.last/all.dat$waa.tm1 # This is the growth estimate we'd use if we used the last year only SST predictive model
all.dat$g.actual <- all.dat$waa.t2/all.dat$waa.tm1 # This is using the actual condition factor and growing the scallops by laa.t
#all.dat$g.aug <- all.dat$waa.t2.aug/all.dat$waa.tm1.aug
# Percent differences, using g.actual as our 'real' scenario. 
all.dat$prec.g.used <- 100*(all.dat$g.used - all.dat$g.actual) / all.dat$g.actual
all.dat$prec.g.all <- 100*(all.dat$g.all - all.dat$g.actual) / all.dat$g.actual
all.dat$prec.g.last <- 100*(all.dat$g.last - all.dat$g.actual) / all.dat$g.actual
#all.dat$prec.g.aug <- 100*(all.dat$g.aug - all.dat$g.actual) / all.dat$g.actual


summary(all.dat$prec.g.used)
summary(all.dat$prec.g.all)
summary(all.dat$prec.g.last)
summary(all.dat$prec.g.aug)

# Now do the same thing for the recruits.
all.dat$wk.tm1 <- all.dat$CF*(all.dat$l.r/100)^3
#all.dat$wk.tm1.aug <- all.dat$CF.aug*(all.dat$l.r/100)^3
all.dat$lk.t <- vonB$Linf*(1-exp(-vonB$K))+exp(-vonB$K)*all.dat$l.r

all.dat$wk.t.used <- all.dat$CF*(all.dat$lk.t/100)^3
all.dat$wk.t.all <- c(all.dat$CF.all[2:nrow(all.dat)],NA)*(all.dat$lk.t/100)^3
all.dat$wk.t.last <-  c(all.dat$CF.last[2:nrow(all.dat)],NA)*(all.dat$lk.t/100)^3
#all.dat$wk.t2.aug <- c(all.dat$CF.aug[2:nrow(all.dat)],NA)*(all.dat$lk.t/100)^3
all.dat$wk.t2 <- c(all.dat$CF[2:nrow(all.dat)],NA)*(all.dat$lk.t/100)^3


all.dat$gr.used <- all.dat$wk.t.used/all.dat$wk.tm1 # This is the growth estimate that would have been used in the model
all.dat$gr.all <- all.dat$wk.t.all/all.dat$wk.tm1 # This is the growth estimate we'd use if we used the full SST predictive model
all.dat$gr.last <- all.dat$wk.t.last/all.dat$wk.tm1 # This is the growth estimate we'd use if we used the last year only SST predictive model
all.dat$gr.actual <- all.dat$wk.t2/all.dat$wk.tm1 # This is using the actual condition factor and growing the scallops by laa.t
#all.dat$gr.aug <- all.dat$wk.t2.aug/all.dat$wk.tm1.aug

# Percent differences, using g.actual as our 'real' scenario
all.dat$prec.gr.used <- 100*(all.dat$gr.used - all.dat$gr.actual) / all.dat$gr.actual
all.dat$prec.gr.all <- 100*(all.dat$gr.all - all.dat$gr.actual) / all.dat$gr.actual
all.dat$prec.gr.last <- 100*(all.dat$gr.last - all.dat$gr.actual) / all.dat$gr.actual
#all.dat$prec.gr.aug <- 100*(all.dat$gr.aug - all.dat$gr.actual) / all.dat$gr.actual #  division.


summary(all.dat$prec.gr.used)
summary(all.dat$prec.gr.all)
summary(all.dat$prec.gr.last)
#summary(all.dat$prec.gr.aug)
# Pivot to long form
#all.dat.long <- all.dat %>% reshape2::melt(id.vars = 'year',value.name = 'response',variable.name = 'covar')



# So what I need to do is replace the last g and gr value in this object with the predicted number and then see how much differences
# that makes in the projection.  We can go back to like 2000 with this no problem I think.

proj.B.yr <- NULL
base.year <- 2019
scenarios <- c("BM.Current","BM.All","BM.Last","BM.Realized")#,"BM.Aug")
for(y in 1987:2019)
{
  pick <- base.year - y+1
  gb.out <- DD.out
  gb.out$data$NY <- gb.out$data$NY-pick
  proj.B <- data.frame("BM.Current"=rep(NA,30000),"BM.All"=rep(NA,30000),
                       "BM.Last"=rep(NA,30000),"BM.Realized" = rep(NA,30000),
                       #"BM.Aug" = rep(NA,30000),
                       "BM.Actual" = rep(NA,30000),
                       "Prop.Current"=rep(NA,30000),"Prop.All"=rep(NA,30000),
                       "Prop.Last"=rep(NA,30000),"Prop.Realized"=rep(NA,30000),
                       #"Prop.Aug"=rep(NA,30000),
                       'year' = rep(y,30000))
  # Now run through 4 scenarios
  for(i in 1:(length(scenarios)))
  {
  # Note these are all y-1 because I put them in the year before in the above (i.e. 1986 g's are for the 1987 projection)
  if(i == 2) 
  {
    gb.out$data$g[gb.out$data$NY] <- all.dat$g.all[all.dat$year == y-1]
    gb.out$data$gR[gb.out$data$NY] <- all.dat$gr.all[all.dat$year == y-1]
  }
  if(i == 3) 
  {
    gb.out$data$g[gb.out$data$NY] <- all.dat$g.last[all.dat$year == y-1]
    gb.out$data$gR[gb.out$data$NY] <- all.dat$gr.last[all.dat$year == y-1]
  }
  if(i == 4) 
  {
    gb.out$data$g[gb.out$data$NY] <- all.dat$g.actual[all.dat$year == y-1]
    gb.out$data$gR[gb.out$data$NY] <- all.dat$gr.actual[all.dat$year == y-1]
  }  
  # if(i == 4) 
  # {
  #   gb.out$data$g[gb.out$data$NY] <- all.dat$g.aug[all.dat$year == y]
  #   gb.out$data$gR[gb.out$data$NY] <- all.dat$gr.aug[all.dat$year == y]
  # }  
  # Note that I don't need to include the projected catch here because the data for catches is for the survey
  # years and so that is all nicely accounted for in this I checked and even 2019 looks to be correct, so no
  # need to do anything here since we only run to 2019... if we had 2020 we'd probably need to get funky.
  res <- projections(gb.out, C.p=(gb.fish.dat$GBa$catch[gb.fish.dat$GBa$year == y])) # C.p = potential catches in decision table
  
  proj.B[scenarios[i]] <- as.vector(res$sims.list$B.p)
  } # end for(i in 1:4)
  proj.B["BM.Actual"] <- as.vector(gb.out$sims.list$B[,gb.out$data$NY+1]) # I want next year's result because I'm projecting forward right!
  proj.B["Prop.Current"] <- (proj.B["BM.Current"] - proj.B["BM.Actual"]) /  proj.B["BM.Actual"]
  proj.B["Prop.All"] <- (proj.B["BM.All"] - proj.B["BM.Actual"]) /  proj.B["BM.Actual"]
  proj.B["Prop.Last"] <- (proj.B["BM.Last"] - proj.B["BM.Actual"]) /  proj.B["BM.Actual"]
  proj.B["Prop.Realized"] <- (proj.B["BM.Realized"] - proj.B["BM.Actual"]) /  proj.B["BM.Actual"]
  #proj.B["Prop.Aug"] <- (proj.B["BM.Aug"] - proj.B["BM.Actual"]) /  proj.B["BM.Actual"]
  # Difference
  proj.B["Diff.Current"] <- (proj.B["BM.Current"] - proj.B["BM.Actual"]) 
  proj.B["Diff.All"] <- (proj.B["BM.All"] - proj.B["BM.Actual"]) 
  proj.B["Diff.Last"] <- (proj.B["BM.Last"] - proj.B["BM.Actual"]) 
  proj.B["Diff.Realized"] <- (proj.B["BM.Realized"] - proj.B["BM.Actual"]) 
  #proj.B["Diff.Aug"] <- (proj.B["BM.Aug"] - proj.B["BM.Actual"])
  proj.B.yr[[as.character(y)]] <- proj.B
  
} # end for(y in 1987:2018)


bm.res <- do.call('rbind',proj.B.yr)


# Now switch the data to long
all.res.long <- bm.res %>% reshape2::melt(id.var = "year")



# I don't think I want the realized method on there, it is kinda relevant but makes story complicated.
bm.res.long <-  all.res.long %>% dplyr::filter(!str_detect(variable,'Realized'), str_detect(variable,'BM'))
prop.res.long <- all.res.long %>% dplyr::filter(!str_detect(variable,'Realized'), str_detect(variable,'Prop'))
diff.res.long <- all.res.long %>% dplyr::filter(!str_detect(variable,'Realized'), str_detect(variable,'Diff'))
#bm.res.long <-  all.res.long %>% dplyr::filter(str_detect(variable,'BM'))
#prop.res.long <- all.res.long %>% dplyr::filter(str_detect(variable,'Prop'))
#diff.res.long <- all.res.long %>% dplyr::filter(str_detect(variable,'Diff'))

# SO we can model the raw data, not sure that's the best plan ever, but let's see!
# So a model...
bm.res.mod <- lm(value~variable,bm.res.long)
summary(bm.res.mod)
diff.res.mod <- lm(value~variable,diff.res.long)
summary(diff.res.mod)
#par(mfrow=c(2,2));plot(diff.res.mod)
prop.res.mod <- lm(value~variable-1,prop.res.long)
summary(prop.res.mod)
#par(mfrow=c(2,2));plot(prop.res.mod)


fit.summary <- all.res.long %>% dplyr::group_by(year,variable) %>% dplyr::summarise(median = median(value),
                                                                                   mn = mean(value),
                                                                                  uqr = quantile(value,probs=0.75,na.rm=T),
                                                                                  lqr = quantile(value,probs=0.25,na.rm=T))


# I don't think I want the realized method on there, it is kinda relevant but makes story complicated.
# It also is just about identical to the "Last" model in terms of results, so really using
# August or May data for the projection doesn't matter as it over-estimates biomass almost identically.
bm.summary <- fit.summary %>% dplyr::filter(!str_detect(variable,'Realized'), str_detect(variable,'BM'))
prop.summary <- fit.summary %>% dplyr::filter(!str_detect(variable,'Realized'), str_detect(variable,'Prop'))
diff.summary <- fit.summary %>% dplyr::filter(!str_detect(variable,'Realized'), str_detect(variable,'Diff'))
#bm.summary <- fit.summary %>% dplyr::filter(str_detect(variable,'BM'))
#prop.summary <- fit.summary %>% dplyr::filter(str_detect(variable,'Prop'))
#diff.summary <- fit.summary %>% dplyr::filter(str_detect(variable,'Diff'))


diff.summary %>% group_by(variable) %>% dplyr::summarise(m = mean(median))

# The labels for the levels...
labs <- c("Full SST Model","Previous Year SST Model","Current Method","Actual")
bm.summary$variable <- factor(bm.summary$variable,levels =c("BM.All","BM.Last","BM.Current","BM.Actual"),
                              labels = labs)
prop.summary$variable <- factor(prop.summary$variable,levels =c("Prop.All","Prop.Last","Prop.Current"),#,"Prop.Aug"),
                              labels = labs[1:3])
diff.summary$variable <- factor(diff.summary$variable,levels =c("Diff.All","Diff.Last","Diff.Current"),#,"Diff.Aug"),
                                labels = labs[1:3])

cols <- addalpha(c("orange","darkgreen","grey20","darkblue"))#,'red'))

# Time series plots
p.bm.ts <- ggplot(bm.summary, aes(x=year,y=median/1000,color = variable, group =variable)) + geom_line(lwd=1.5) +
                geom_ribbon(aes(x=year,ymin=lqr/1000,ymax=uqr/1000,fill=variable,group = variable),alpha = 0.5) +
                xlab("") + ylab("Biomass (kilotonnes)") +
                scale_fill_manual(values = cols) +
                scale_color_manual(values=cols) + 
                scale_x_continuous(breaks = seq(1987,2020,by=3),limits = c(1987,2020)) +
                theme(legend.position = "top",axis.text.x=element_blank(),legend.title = element_blank())

# Grab the legend then remove it from the figure....
leg <- get_legend(p.bm.ts)
p.bm.ts <- p.bm.ts + theme(legend.position = "none")
#grobs <- ggplotGrob(p.bm.ts)$grobs
#leg <- grobs[[which(sapply(grobs, function(x) x$name) == "guide-box")]]

p.diff.ts <- ggplot(diff.summary, aes(x=year,y=median/1000,color = variable, group =variable)) + geom_line(lwd=1.5) +
                geom_ribbon(aes(x=year,ymin=lqr/1000,ymax=uqr/1000,fill=variable,group = variable),alpha = 0.5) +
                xlab("") + ylab("Difference from Actual Biomass (kilotonnes)") +
                scale_fill_manual(values = cols[1:3]) +
                scale_color_manual(values=cols[1:3]) + 
                geom_hline(yintercept = 0)+ 
                scale_x_continuous(breaks = seq(1987,2020,by=3),limits = c(1987,2020)) +
                theme(legend.position = "none",axis.text.x=element_blank())

p.prop.ts <- ggplot(prop.summary, aes(x=year,y=100*median,color = variable, group =variable)) + geom_line(lwd=1.5) +
                geom_ribbon(aes(x=year,ymin=100*lqr,ymax=100*uqr,fill=variable,group = variable),alpha = 0.5) +
                xlab("") + ylab("Difference from Actual Biomass (%)") +
                scale_fill_manual(values = cols[1:3]) +
                scale_color_manual(values=cols[1:3]) + 
                geom_hline(yintercept = 0)+
                scale_x_continuous(breaks = seq(1987,2020,by=3),limits = c(1987,2020)) +
                theme(legend.position = "none")
              

p.ts <- plot_grid(leg,p.bm.ts,p.diff.ts,p.prop.ts,ncol=1,rel_heights = c(0.1,1,1,1))

save_plot(plot = p.ts, filename = "D:/Github/Paper_2_Cond_Env/Results/Figures/timeseries_bm_comparision.png", base_width = 6,base_height = 10)




## Now we can fit a model which should replace the below fun...


# So a model...
bm.mod <- lm(median~variable,bm.summary)
summary(bm.mod)
diff.mod <- lm(median~variable,diff.summary)
summary(diff.mod)
par(mfrow=c(2,2));plot(diff.mod)
prop.mod <- lm(median~variable,prop.summary)
summary(prop.mod)
par(mfrow=c(2,2));plot(prop.mod)

d.mod.pred <- data.frame(variable = unique(diff.summary$variable))
d.mod.pred$est <- predict(diff.mod,d.mod.pred)
d.mod.pred$se <- predict(diff.mod,d.mod.pred,se=T)$se.fit
d.mod.pred$uci <- d.mod.pred$est + 2*d.mod.pred$se
d.mod.pred$lci <- d.mod.pred$est - 2*d.mod.pred$se
# Now the proportion model...
p.mod.pred <- data.frame(variable = unique(diff.summary$variable))
p.mod.pred$est <- predict(diff.mod,p.mod.pred)
p.mod.pred$se <- predict(diff.mod,p.mod.pred,se=T)$se.fit
p.mod.pred$uci <- p.mod.pred$est + 2*p.mod.pred$se
p.mod.pred$lci <- p.mod.pred$est - 2*p.mod.pred$se


p.diff <- ggplot(d.mod.pred,  aes(x=variable,y=est/1000)) + geom_point(lwd=2) +
                                  geom_errorbar(aes(x=variable,ymin=lci/1000,ymax=uci/1000),width=0) +
                                  xlab("") + ylab("Difference from Actual Biomass (kilotonnes)") +
                                  scale_fill_manual(values = cols[1:3]) +
                                  scale_color_manual(values=cols[1:3]) + 
                                  geom_hline(yintercept = 0,linetype=2)+
                                  scale_y_continuous(breaks = seq(-3,6,by=1)) +
                                  theme(legend.title = element_blank())

p.prop <- ggplot(prop.overall, aes(x=variable,y=100*med)) + geom_point(lwd=2) +
                                  geom_errorbar(aes(x=variable,ymin=100*lqr,ymax=100*uqr),width=0) +
                                  xlab("") + ylab("Difference from Actual Biomass (%)") +
                                  scale_fill_manual(values = cols[1:3]) +
                                  scale_color_manual(values=cols[1:3]) + 
                                  geom_hline(yintercept = 0,linetype=2)+
                                  scale_y_continuous(breaks = seq(-20,40,by=10)) +
                                  theme(legend.title = element_blank())



p <- plot_grid(p.diff,p.prop,ncol=1)

save_plot(plot = p, filename = "D:/Github/Paper_2_Cond_Env/Results/Figures/Overall_effect.png", base_width = 6,base_height =10 )

```







```{r overveiw-fig, echo=F, include=F, paged.print=FALSE,cache =T}
################################
###  Figures for the paper  ###
################################

# Plane old map
bp <-  pecjector(area="GOM",plot=F,repo = 'github',add_layer = list(land ='grey',eez = 'eez',nafo = 'main',scale.bar = 'tl'),c_sys = 32619,buffer = 0.2) + theme_map()

# I'll need to carve out the 120 meter bathymetry polygon and add it to this figure.
 
save_plot(paste0(direct.proj,"Results/Figures/GB_overview.png"),plt.over,base_width =6,base_height =8,units='in',dpi=300)
save_plot(paste0(direct.proj,"Results/Figures/GB_overview.tiff"),plt.over,base_width =6,base_height =8,units='in',dpi=300)
#over.plt <- paste0(direct.proj,"Results/Figures/GB_overview.png")
```


```{r mesh-plt, echo=F, include=F, paged.print=FALSE,cache =T}

#####
# Figure MESH don't need to run this every time, if I want to change something uncomment the below
#####

# I'm gonna need to plot my mesh on the nice bp object
mesh.gf$crs <- crs("+init=epsg:32619") 
# THis is a very minor tweak on a custom function from Finn Lindgren https://groups.google.com/forum/#!topic/r-inla-discussion-group/z1n1exlZrKM
mesh.sf <- inla.mesh2sf(mesh.gf)

plt.mesh <- pecjector(area = "GOM",buffer=0.4, c_sys = 32619,plot=F,
                     add_layer = list(land ='grey',eez = 'eez',nafo = 'main',scale.bar = 'tl'),
                     add_custom = list(obj = mesh.sf$triangles, size=0.5,color= 'grey30')) +
                     theme_map()
save_plot(paste0(direct.proj,"Results/Figures/mesh.tiff"),plt.mesh,base_width =8,base_height =8,units='in')
save_plot(paste0(direct.proj,"Results/Figures/mesh.png"),plt.mesh,base_width =8,base_height =8,units='in')
#mesh.plt <- paste0(direct.proj,"Results/Figures/mesh.png")
```
